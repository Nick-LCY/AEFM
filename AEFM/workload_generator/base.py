from . import WorkloadGeneratorInterface
from ..utils.logger import log
import re, subprocess, pathlib
from typing import List
from ..utils.files import delete_path, create_folder, write_to_file

SCRIPTS_FOLDER = (
    pathlib.Path(__file__).parent.resolve().joinpath("wrk_scripts")
)


class WrkConfig:
    def __init__(
        self,
        wrk_path: str,
        url: str,
        threads: int,
        connections: int,
        duration: str,
        script: str,
        rate: int,
    ) -> None:
        """Command line args of wrk programs, please check wrk manual for more
        details, please visit: https://github.com/giltene/wrk2

        Args:
            wrk_path (str): Where to find wrk program. If it is already in "PATH", simply using `wrk` or `wrk2` is OK.
            url (str): Target website.
            threads (int): Number of threads to use.
            connections (int): Connections to keep open.
            duration (str): Duration of test.
            script (str): Load Lua script file.
            rate (int): Work rate (throughput) in requests/sec (total).
        """
        self.wrk_path = wrk_path
        self.threads = threads
        self.connections = connections
        self.duration = duration
        self.rate = rate
        self.script = script.replace("$MODULE_DEFAULT", SCRIPTS_FOLDER.as_posix())
        self.url = url

    def get_cmd(self) -> str:
        """Parse configs into command.

        Returns:
            str: Command that used to run wrk program.
        """
        return (
            f"{self.wrk_path} {self.url} "
            f"-t {self.threads} "
            f"-c {self.connections} "
            f"-d {self.duration} "
            f"-s {self.script} "
            f"-R {self.rate}"
        )


class BaseWorkloadGenerator(WorkloadGeneratorInterface):
    """An encapsulation of wrk program, generates workload and provides real thr
    oughput information. To use this class, please make sure that you have alrea
    dy build a runnable wrk program. For more information, please check: https:/
    /github.com/giltene/wrk2
    """

    def __init__(self, wrk_config: WrkConfig, output_path: str) -> None:
        """Create wrk workload generator, save information at ``output_path``.

        Args:
            wrk_config (WrkConfig): Specify wrk configs, such as threads, connec
            tions.
            output_path (str): Specify where the wrk output file should be store
            d.
        """
        self.wrk_config = wrk_config
        self.command = wrk_config.get_cmd()
        self.throughput_path = f"{output_path}/throughput"
        self.wrk_output_path = f"{output_path}/wrk_output"
        # Create output folder
        create_folder(self.throughput_path)
        create_folder(self.wrk_output_path)

    def run(self, workload: int, test_case_name: str) -> int:
        """Start wrk programs and generate workload.

        Args:
            workload (int): Throughput, units: requests/second.
            test_case_name (str): Used to identify different test cases.

        Returns:
            int: Real throughput generated by wrk programs.
        """
        # Compute number of wrk clients based on required workload and wrk_config
        clients = workload // self.wrk_config.rate
        # Open multiple subprocesses to run multiple clients simultaneously
        processes: List[subprocess.Popen] = []
        log.debug(f"{__file__}: clients {clients}, command: {self.command}")
        for _ in range(clients):
            proc = subprocess.Popen(self.command, stdout=subprocess.PIPE, shell=True)
            processes.append(proc)
        # Read and analyze output data
        cumulative_requests = 0
        delete_path(f"{self.wrk_output_path}/{test_case_name}")
        delete_path(f"{self.throughput_path}/{test_case_name}")
        for proc in processes:
            (out, _) = proc.communicate()
            content = out.decode("utf-8")
            match = re.search(r"(\d+)\srequests", content)
            log.debug(f"{__file__}: wrk output\n {content}")
            write_to_file(
                f"{self.wrk_output_path}/{test_case_name}", content, append=True
            )
            if match is not None:
                cumulative_requests += int(match.group(1))
        throughput = cumulative_requests / self.wrk_config.duration
        write_to_file(f"{self.throughput_path}/{test_case_name}", f"{throughput}\n")
